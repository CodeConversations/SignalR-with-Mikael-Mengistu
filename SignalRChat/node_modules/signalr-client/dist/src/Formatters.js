(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function splitAt(input, searchString, position) {
        let index = input.indexOf(searchString, position);
        if (index < 0) {
            return [input.substr(position), input.length];
        }
        let left = input.substring(position, index);
        return [left, index + searchString.length];
    }
    var TextMessageFormat;
    (function (TextMessageFormat) {
        const InvalidPayloadError = new Error("Invalid text message payload");
        const LengthRegex = /^[0-9]+$/;
        function hasSpace(input, offset, length) {
            let requiredLength = offset + length;
            return input.length >= requiredLength;
        }
        function parseMessage(input, position) {
            var offset = position;
            // Read the length
            var [lenStr, offset] = splitAt(input, ":", offset);
            // parseInt is too leniant, we need a strict check to see if the string is an int
            if (!LengthRegex.test(lenStr)) {
                throw new Error(`Invalid length: '${lenStr}'`);
            }
            let length = Number.parseInt(lenStr);
            // Required space is: (";") + length (payload len)
            if (!hasSpace(input, offset, 1 + length)) {
                throw new Error("Message is incomplete");
            }
            // Read the payload
            var payload = input.substr(offset, length);
            offset += length;
            // Verify the final trailing character
            if (input[offset] != ';') {
                throw new Error("Message missing trailer character");
            }
            offset += 1;
            return [offset, payload];
        }
        function write(output) {
            return `${output.length}:${output};`;
        }
        TextMessageFormat.write = write;
        function parse(input) {
            if (input.length == 0) {
                return [];
            }
            let messages = [];
            var offset = 0;
            while (offset < input.length) {
                let message;
                [offset, message] = parseMessage(input, offset);
                messages.push(message);
            }
            return messages;
        }
        TextMessageFormat.parse = parse;
    })(TextMessageFormat = exports.TextMessageFormat || (exports.TextMessageFormat = {}));
});
